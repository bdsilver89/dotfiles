return {
  "rebelot/heirline.nvim",
  event = "BufEnter",
  config = function()
    local heirline = require("heirline")
    local utils = require("heirline.utils")
    local Utils = require("bdsilver89.utils")
    local conditions = require("heirline.conditions")

    local function setup_colors()
      return {
        bright_bg = utils.get_highlight("Folded").bg,
        bright_fg = utils.get_highlight("Folded").fg,
        red = utils.get_highlight("DiagnosticError").fg,
        dark_red = utils.get_highlight("DiffDelete").bg,
        green = utils.get_highlight("String").fg,
        blue = utils.get_highlight("Function").fg,
        gray = utils.get_highlight("NonText").fg,
        orange = utils.get_highlight("Constant").fg,
        purple = utils.get_highlight("Statement").fg,
        cyan = utils.get_highlight("Special").fg,
        diag_warn = utils.get_highlight("DiagnosticWarn").fg,
        diag_error = utils.get_highlight("DiagnosticError").fg,
        diag_hint = utils.get_highlight("DiagnosticHint").fg,
        diag_info = utils.get_highlight("DiagnosticInfo").fg,
        git_del = utils.get_highlight("diffDeleted").fg,
        git_add = utils.get_highlight("diffAdded").fg,
        git_change = utils.get_highlight("diffChanged").fg,
      }
    end

    local components = require("bdsilver89.plugins.heirline.components")
    local DefaultStatusLine = {
      components.vimode(),
      components.space(),
      -- -- Spell,
      -- -- WorkDir,
      components.file_name_block(),
      { provider = "%<" },
      components.space(),
      -- -- Git,
      components.space(),
      -- -- Diagnostics,
      components.align(),
      -- -- Navic?
      components.align(),
      -- -- DAPMessages,
      components.lsp_active(),
      components.space(),
      -- FileType,
      { flexible = 3, { components.file_encoding(), components.space() }, { provider = "" } },
      components.space(),
      components.ruler(),
      -- -- SearchCount,
      components.space(),
      -- ScrollBar,
    }

    local InactiveStatusLine = {
      condition = conditions.is_not_active,
      -- { hl = { fg = "gray", force = true }, WorkDir },
      components.file_name_block(),
      { provider = "%<" },
      components.align(),
    }

    local TerminalStatusLine = {
      condition = conditions.buffer_matches({ buftype = { "terminal" } }),
    }

    local SpecialStatusLine = {
      condition = conditions.buffer_matches({
        buftype = { "nofile", "help", "quickfix" },
        filetype = { "^git.*", "fugitive" },
      }),
      components.file_type(),
      { provider = "%q" },
      components.space(),
      -- help filename
      components.align(),
    }

    local StatusLines = {
      hl = function()
        if conditions.is_active() then
          return "StatusLine"
        else
          return "StatusLineNC"
        end
      end,
      static = {
        mode_colors = {
          n = "red",
          i = "green",
          v = "cyan",
          V = "cyan",
          ["\22"] = "cyan", -- this is an actual ^V, type <C-v><C-v> in insert mode
          c = "orange",
          s = "purple",
          S = "purple",
          ["\19"] = "purple", -- this is an actual ^S, type <C-v><C-s> in insert mode
          R = "orange",
          r = "orange",
          ["!"] = "red",
          t = "green",
        },
        mode_color = function(self)
          local mode = conditions.is_active() and vim.fn.mode() or "n"
          return self.mode_colors[mode]
        end,
      },
      fallthrough = false,
      InactiveStatusLine,
      DefaultStatusLine,
    }

    local WinBar = {
      fallthrough = false,
      {
        condition = function()
          return conditions.buffer_matches({ buftype = { "terminal" } })
        end,
        utils.surround({ "", "" }, "dark_red", {
          components.file_type(),
          components.space(),
          -- TerminalName,
          components.close_button(),
        }),
      },
      utils.surround({ "", "" }, "bright_bg", {
        fallthrough = false,
        {
          condition = conditions.is_not_active,
          {
            hl = { fg = "bright_fg", force = true },
            components.file_name_block(),
          },
          components.close_button(),
        },
        {
          -- navic
          { provider = "%<" },
          components.align(),
          components.file_name_block(),
          components.close_button(),
        },
      }),
    }

    local TabLine = {}

    local StatusColumn = {
      static = {
        get_signs = function()
          local buf = vim.fn.expand("%")
          return vim.tbl_map(function(sign)
            return vim.fn.sign_getdefined(sign.name)[1]
          end, vim.fn.sign_getplaced(buf, { group = "*", lnum = vim.v.lnum })[1].signs)
        end,
        resolve = function(self, name)
          for pat, cb in pairs(self.handlers) do
            if name:match(pat) then
              return cb
            end
          end
        end,
        handlers = {
          ["GitSigns.*"] = function(args)
            require("gitsigns").preview_hunk_inline()
          end,
          ["Dap.*"] = function(args)
            require("dap").toggle_breakpoint()
          end,
          ["Diagnostic.*"] = function(args)
            vim.diagnostic.open_float()
          end,
        },
      },
      {
        provider = "%s",
        on_click = {
          name = "heirline_signcol_callback",
          update = true,
          callback = function(self, ...)
            local mousepos = vim.fn.getmousepos()
            vim.api.nvim_win_set_cursor(0, { mousepos.line, mousepos.column })
            local sign_at_cursor = vim.fn.screenstring(mousepos.screenrow, mousepos.screencol)
            if sign_at_cursor ~= "" then
              local args = {
                mousepos = mousepos,
              }
              local signs = vim.fn.sign_getdefined()
              for _, sign in ipairs(signs) do
                local glyph = sign.text:gsub(" ", "")
                if sign_at_cursor == glyph then
                  vim.defer_fn(function()
                    self:resolve(sign.name)(args)
                  end, 10)
                  return
                end
              end
            end
          end,
        },
      },
      {
        provider = "%=%4{v:virtnum ? '' : &nu ? (&rnu && v:relnum ? v:relnum : v:lnum) . ' ' : ''}",
      },
      {
        provider = "%{% &fdc ? '%C' : '' %}",
      },
    }

    local opts = {
      opts = {
        disable_winbar_cb = function(args)
          if vim.bo[args.buf].filetype == "neo-tree" then
            return
          end
          return not require("bdsilver89.utils").valid_buffer(args.buf)
            or conditions.buffer_matches({
              buftype = { "terminal", "prompt", "nofile", "help", "quickfix" },
              filetype = { "neo%-tree", "dashboard", "Outline", "aerial" },
            }, args.buf)
        end,
        colors = setup_colors(),
      },
      statusline = StatusLines,
      winbar = WinBar,
      tabline = TabLine,
      statuscolumn = StatusColumn,
    }

    heirline.setup(opts)

    local group = vim.api.nvim_create_augroup("Heirline", { clear = true })
    vim.api.nvim_create_autocmd("ColorScheme", {
      group = group,
      callback = function()
        utils.on_colorscheme(setup_colors())
      end,
    })
  end,
}
